WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.554
Hi, in this video we're going to provide a brief solidity review.

00:00:04.554 --> 00:00:09.175
As always, for full resources in regards to developer documentation,

00:00:09.175 --> 00:00:12.730
head over to solidities developer documentation support,

00:00:12.730 --> 00:00:14.134
utilizing your handling blow.

00:00:14.134 --> 00:00:19.550
Topics covered in this section are: solidity versioning, contracts,

00:00:19.550 --> 00:00:25.880
variable types such as booleans, integers, addresses, strings.

00:00:25.879 --> 00:00:27.960
We'll go in more detail in regards to

00:00:27.960 --> 00:00:31.325
variable definition regarding arithmetic operations,

00:00:31.324 --> 00:00:34.814
we'll navigate to structs and conclude with mappings.

00:00:34.814 --> 00:00:38.280
Let's go over some comments solidity syntax.

00:00:38.280 --> 00:00:41.300
Now, remember this is geared for quick review.

00:00:41.299 --> 00:00:44.265
So, we're going to walk you through some basic concepts,

00:00:44.265 --> 00:00:47.600
but you should always go ahead and head over to

00:00:47.600 --> 00:00:52.760
the developer documentation for full review regarding the resources,

00:00:52.759 --> 00:00:55.564
and tooling for your smart contract development.

00:00:55.564 --> 00:00:57.879
First up, solidity versioning.

00:00:57.880 --> 00:01:02.565
Solidity source files can contain any number of contract definitions.

00:01:02.564 --> 00:01:07.060
Each solidity files also includes a thing called version pragma.

00:01:07.060 --> 00:01:11.240
It is used to prevent the code from being compiled with future compile or

00:01:11.239 --> 00:01:15.754
versions that might introduce incompatible changes with your smart contract.

00:01:15.754 --> 00:01:18.784
Most of the time the definition looks like this.

00:01:18.784 --> 00:01:25.459
In the example, 0.420 is the desired compiler version.

00:01:25.459 --> 00:01:31.134
Contracts in solidity are similar to classes in object-oriented languages.

00:01:31.135 --> 00:01:33.609
They contain data, and variables,

00:01:33.609 --> 00:01:36.890
and functions that can modify these variables.

00:01:36.890 --> 00:01:40.295
They're defined by using a contract keyword,

00:01:40.295 --> 00:01:42.710
followed by the contract name,

00:01:42.709 --> 00:01:48.309
and two curly brackets which later encloses the contract variables and its functions.

00:01:48.310 --> 00:01:52.310
Let's start by finding out what type of variables there are.

00:01:52.310 --> 00:01:54.543
First up, state variables.

00:01:54.543 --> 00:01:58.500
State variables are used to store information on the blockchain.

00:01:58.500 --> 00:02:02.349
They can also be manipulated by the functions within the contract.

00:02:02.349 --> 00:02:06.129
Solidity is a statically typed programming language,

00:02:06.129 --> 00:02:10.594
meaning that each variable must have its type specified.

00:02:10.594 --> 00:02:13.780
Examples of the main datatypes.

00:02:13.780 --> 00:02:19.905
Booleans. Contracts only have one of the following values: true or false.

00:02:19.905 --> 00:02:22.800
The keyword for boolean is bool.

00:02:22.800 --> 00:02:27.005
Integers can be split into two main groups,

00:02:27.004 --> 00:02:30.824
regular integers and unsigned integers.

00:02:30.824 --> 00:02:34.774
Regular integers can store both positive and negative values while

00:02:34.775 --> 00:02:39.270
unsigned integers can only store values that are zero or higher.

00:02:39.270 --> 00:02:45.135
Regular answers has keyword INTA to INT 256.

00:02:45.134 --> 00:02:49.189
The number specifies that the maximum number of bits it can store,

00:02:49.189 --> 00:02:55.109
thus limiting the maximum value and it could be any number between eight and 256,

00:02:55.110 --> 00:02:58.635
as long as it's incremented in steps of eight.

00:02:58.634 --> 00:03:03.509
The INT keyword alone would be understood as INT 256.

00:03:03.509 --> 00:03:06.979
Now that you've learned to define the variables for your contract,

00:03:06.979 --> 00:03:10.969
it's time to go through some basic math commands that will be useful later for

00:03:10.969 --> 00:03:15.914
defining your smart contracts code, arithmetic operations.

00:03:15.914 --> 00:03:21.554
Integers can be used for arithmetic operations, such as addition,

00:03:21.555 --> 00:03:25.615
subtraction, multiplication, division, remainder,

00:03:25.615 --> 00:03:27.960
exponents and so forth.

00:03:27.960 --> 00:03:36.254
A real-world example of utilizing arithmetics is referencing back to our pizza example.

00:03:36.254 --> 00:03:38.819
Here, we define the pizzaSlices,

00:03:38.819 --> 00:03:42.449
the number of people and the slicesPerPerson.

00:03:42.449 --> 00:03:45.844
That's the moment where we need to apply arithmetics.

00:03:45.844 --> 00:03:50.229
SlicesPerPerson, pizzaSlices divided by people.

00:03:50.229 --> 00:03:51.903
Next up, structs.

00:03:51.903 --> 00:03:54.960
As we've learned the basics for defining variables,

00:03:54.960 --> 00:04:00.405
now we learn to create the structure that defines your variable properties.

00:04:00.405 --> 00:04:05.814
A struck is a special data type that allows a programmer to group a list of variables.

00:04:05.814 --> 00:04:08.349
Structures are defined like this.

00:04:08.349 --> 00:04:12.954
In this example, we're going to define a structure called Car.

00:04:12.955 --> 00:04:15.945
With that we have some variables like make,

00:04:15.944 --> 00:04:19.370
model, year, and horsepower.

00:04:19.370 --> 00:04:22.985
Pretty simple. With that,

00:04:22.985 --> 00:04:26.395
you can combine structs and utilize mappings.

00:04:26.394 --> 00:04:28.899
Now, that you've defined your variables,

00:04:28.899 --> 00:04:33.714
we'll learn how to create a variable that will later map your variable to the blockchain,

00:04:33.714 --> 00:04:37.354
a special list where all other variables are stored.

00:04:37.355 --> 00:04:42.965
Mappings allow the programmer to create key-value pairs and store them as a list.

00:04:42.964 --> 00:04:46.669
Concepts like this are also known as hash tables.

00:04:46.670 --> 00:04:50.370
Mappings are defined like this.

00:04:50.370 --> 00:04:52.769
We have a key_type,

00:04:52.769 --> 00:04:57.454
and the key_value, and then we define it in name.

00:04:57.454 --> 00:05:00.219
Key_types should be replaced by a data type.

00:05:00.220 --> 00:05:04.945
Two commonly used variable type for mapping keys,

00:05:04.944 --> 00:05:07.959
we already know about our addresses and uint.

00:05:07.959 --> 00:05:12.329
It's important to know that not every data type can be used as a key.

00:05:12.329 --> 00:05:16.240
For instance, structs and other mapping cannot be used as keys.

00:05:16.240 --> 00:05:21.835
Similarly, key_value should only be replaced by the value type.

00:05:21.834 --> 00:05:26.479
Unlike with keys, solidity does not limit the data types for value.

00:05:26.480 --> 00:05:30.230
It can be anything including structs and other mappings.

00:05:30.230 --> 00:05:34.245
Here, we have mapping with the address,

00:05:34.245 --> 00:05:37.774
assign it at uint256 with the name of balance.

00:05:37.774 --> 00:05:41.359
This mapping could hold the bank account balance in

00:05:41.360 --> 00:05:45.850
uint256 for the given address. A quick recap.

00:05:45.850 --> 00:05:48.020
We went over the definitions of defining

00:05:48.019 --> 00:05:51.274
your preferred solidity compiler and its version.

00:05:51.274 --> 00:05:54.044
We discussed variable types, arithmetic,

00:05:54.045 --> 00:05:57.274
and supporting operations for structs and mappings.

00:05:57.274 --> 00:06:00.769
I hope that this introduction to solidity

00:06:00.769 --> 00:06:04.680
helps jump-start your creative process while you work through your project.

